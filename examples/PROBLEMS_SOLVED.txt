● Fibonacci example - LLVM 18.x API compatibility (FIXED)

  Problem: getOrInsertFunction() returns FunctionCallee instead of Function*

  Fix: Call .getCallee() to extract the Function pointer

  Example:
    Function *FibF = cast<Function>(
      M->getOrInsertFunction("fib", Type::getInt32Ty(Context),
                            Type::getInt32Ty(Context)).getCallee());

● Kaleidoscope Chapter 8 - Link errors with all targets (FIXED)

  Problem: Using LLVM_LINK_COMPONENTS "all" and InitializeAll*() functions
  caused undefined references because not all LLVM targets are built in the
  system installation.

  Fix:
  - In CMakeLists.txt: Replace "all" with specific components needed
    (Analysis, Core, ExecutionEngine, InstCombine, MC, Object, OrcJIT,
     Passes, RuntimeDyld, ScalarOpts, Support, Target, TransformUtils, native)

  - In toy.cpp: Replace InitializeAll*() with native-only versions:
    InitializeAllTargetInfos() -> removed
    InitializeAllTargets() -> InitializeNativeTarget()
    InitializeAllTargetMCs() -> removed
    InitializeAllAsmParsers() -> InitializeNativeTargetAsmParser()
    InitializeAllAsmPrinters() -> InitializeNativeTargetAsmPrinter()

● BrainF subdirectory - Multiple LLVM 18.x API compatibility issues (NOT FIXED)

  - getOrInsertFunction() returns FunctionCallee (needs .getCallee())
  - Type::getInt8PtrTy() removed in opaque pointer migration (should use PointerType::get(Context, 0))
  - CallInst::CreateMalloc() and CreateFree() removed (need to use builder pattern or malloc/free calls)
  - CreateGEP() needs explicit type parameter
  - LoadInst constructor signature changed

● Cannot find libEdit

  $ sudo apt install libedit-dev

● Get llvm examples

  $ sudo apt install llvm-18-example

● Perfect! Your codebase has several examples of pass managers in action. Here's a concrete example from toy/toy4.cpp (Kaleidoscope
  tutorial):

  Real Example from Your Codebase

  Setup (toy/toy4.cpp:572-590)
  // Create new pass and analysis managers
  TheFPM = std::make_unique<FunctionPassManager>();
  TheLAM = std::make_unique<LoopAnalysisManager>();
  TheFAM = std::make_unique<FunctionAnalysisManager>();
  TheMAM = std::make_unique<ModuleAnalysisManager>();

  // Add optimization passes to the pass manager
  TheFPM->addPass(InstCombinePass());      // Peephole optimizations
  TheFPM->addPass(ReassociatePass());      // Reassociate expressions
  TheFPM->addPass(GVNPass());              // Eliminate common subexpressions
  TheFPM->addPass(SimplifyCFGPass());      // Simplify control flow

  Execution (toy/toy4.cpp:548)
  // After generating IR for a function, optimize it:
  TheFPM->run(*TheFunction, *TheFAM);

  What Happens When You Run It?

  When TheFPM->run() executes, the pass manager:
  1. Runs InstCombinePass on the function (combines redundant instructions)
  2. Runs ReassociatePass (reorders expressions for better optimization)
  3. Runs GVNPass (removes duplicate computations)
  4. Runs SimplifyCFGPass (removes unreachable code, merges blocks)

  Each pass transforms the IR to make it more efficient. Without the pass manager, you'd manually call each optimization and track
  dependencies yourself.

  Why Use a Pass Manager?

  - Convenience: Add passes once, run them automatically
  - Dependency management: Automatically tracks what analyses are needed
  - Performance: Caches analysis results, only recomputes when needed
  - Correctness: Ensures passes run in valid order

  The pass manager is essential for building compilers - it's how clang, rustc, and other LLVM-based compilers optimize code!
